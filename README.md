# doc-word2vec

## Introduction
This project implements a method to train dynamic word embeddings based on document attributes such as publication date, topic and writer's age, thereby training three-dimensional word embeddings that capture specific features of each word in the context of the input dataset. Previous work can be found [here](https://arxiv.org/abs/1703.00607), which trains year-specific word embeddings in the New York Times dataset crawled between 1990 to 2016. The *baseline* of this project refers to word embeddings generated by the authors of this study. We extend this analysis by training word embeddings based on novel features, including age and document topic, from an independent dataset.

## Dataset
The dataset for this project is taken from the Blog Authorship Corpus, which contains over 680,000 posts from 19,320 different bloggers spanning ages between 13 to 47, topics ranging from banking to technology. The wide variety of features present within the dataset allows for diverse approaches to build customized word embeddings. A sample of the raw dataset is shown below.

|ID|gender|age|topic|sign|date|text|
|---|---|---|---|---|---|---|
|0001|male|24|Food|Aries|14,May,2004|I ate pizza today...|

The full dataset can be downloaded [here](https://www.kaggle.com/rtatman/blog-authorship-corpus).

All pre-processed data (more description below) for the project can be found [here](https://drive.google.com/open?id=1UM289agQDAwjwO30izEh7dTI428suyww).

## Setup
First, clone the following repository and configure a Python interpreter.

On the command line, install the relevant libraries on the Python.

`pip install h5py nltk numpy pandas swifter`

If the single-line command does not work, install the libraries separately.

Next, download preprocessed data from the [link](https://drive.google.com/open?id=1UM289agQDAwjwO30izEh7dTI428suyww) above to quickly explore the project. To unzip the tar gzipped file on the drive, run the following on the command line (for linux systems):

`tar -zxvf embeddings.tar.gz`

Rename the extracted files as indicated by the following table:

|Google Drive|Local Folder|
|---|---|
|data1.tar.gz|blog_dataset_time.h5|
|data2.tar.gz|blog_dataset_age.h5|
|data3.tar.gz|blog_dataset_topic.h5|
|baseline_embeddings.tar.gz|baseline_embeddings.h5|
|embeddings.tar.gz|embeddings-time-5iter.h5, embeddings-age-5iter.h5|
|embeddings.topic.gz|embeddings-topic-human-5iter.h5, embeddings-topic-ppmi_cosine-5iter.h5|
|blog_vocab_date.pkl|blog_vocab_date.pkl|
|blog_vocab_age.pkl|blog_vocab_age.pkl|
|blog_vocab_topic.pkl|blog_vocab_topic.pkl|
|topics_human.npy|topics_human.npy|
|topics_ppmi_cosine.npy|topics_ppmi_cosine.npy|

The raw dataset can be downloaded [here](https://www.kaggle.com/rtatman/blog-authorship-corpus), and must be named as **blogtext.csv** for the preprocessing code to function properly.

Ensure that the directory is set up as the following:
```
-project
    |-baseline
        -baseline_embeddings.h5
        -baseline_vocab.pkl
    |-data
        -blogtext.csv
        -topics_human.npy
        -topics_ppmi_cosine.npy
    |-embeddings
        -embeddings-time-5iter.h5
        -embeddings-age-5iter.h5
        -embeddings-topic-human-5iter.h5
        -embeddings-topic-ppmi_cosine-5iter.h5
    -blog_dataset_age.h5
    -blog_dataset_time.h5
    -blog_dataset_topic.h5
    -blog_vocab_age.pkl
    -blog_vocab_date.pkl
    -blog_vocab_topic.pkl
    -blog_trajectory.py
    -generate_expert_adj.py
    -nyt_trajectory.py
    -preprocess_blogs.py
    -score.py
    -topic_relations.py
    -train_embeddings.py
    -train_embeddings_graph.py
```

Again, check that the project directory structure and file names match the format provided above.

## Workflow

The workflow of this project is mainly divided into three steps:

**Preprocessing** => **Training** => **Evaluation**

Data has been provided as input for all steps in the process. Refer to the sections below for more information on each step.

## Preprocessing
Compared to formalized texts such as news reports or scientific articles, blogs inherently lack consistency and structure, thereby requiring a careful preprocessing step to remove noise from the training dataset. The preprocessing methods taken in this project are as follows, in order:

1. Removal of null values, short posts, foreign languages, ill-formatted data
2. Extraction of date/age information
3. Removal of posts within under-represented categories (date, age, topic)
4. Tokenization and Lemmatization using perceptron-based POS taggers and WordNet from NLTK
5. Construction of vocabulary set, filtering outlier words in terms of frequency
6. Generation of term-context matrix using a sliding window
7. Computation of PPMI matrix over different values of user-defined feature

To preprocess the data, simply run the following in the terminal:

`python preprocess_blogs.py`

Hyperparameters including category of interest (including date, age, and topic), window size, threshold for filtering underrepresented categories, etc. can be tuned within the file.

The PPMI matrices generated over different values of user-selected category (default is date) are stored in **blog_dataset.h5**.

## Training
The three-dimensional PPMI matrices generated serve as inputs to a custom loss function to train word embeddings. As mentioned in the previous paper, Block Coordinate Descent (BCD) is used to effectively train word embeddings through improved asymptotic runtime.

First, word embeddings spanning either publication dates or age brackets can be trained using a sequential approach. To train the word embeddings, run the following in the command line:

`python train_embeddings.py`

Hyperparameters including number of training iterations, coefficients in the loss function, embedding dimension and batch size can be tuned within the file.

The word embeddings, trained over five iterations, are stored in HDF files **embeddings-time-5iter.h5** or **embeddings-age-5iter.h5** in the **embeddings** folder.

Next, topic-based word embeddings can be trained using a graph approach, using the adjacency matrix computed by either humans in **topics_human.npy** or by document-based similarity measure in **topics_ppmi_cosine.npy**. Both adjacency matrices are stored in the **data** folder. To train the graph-based embeddings, run:

`python train_embeddings_graph.py`

Again, hyperparameters such as adjacency matrix option, number of training iterations, embeddings dimension, etc. can be tuned within the file.

The word embeddings, trained over five iterations, are stored in the HDF file **embeddings-topic-5iter.h5** in the **embeddings** folder.

If interested in generating the adjacency matrix itself, run

`python generate_expert_adj.py`

to input custom user opinions or run

`python topic_relations.py`

to generate the document-based topic adjacency matrix.

## Baseline Evaluation
The baseline evaluation script computes the 2D t-SNE projection of a word and returns the most similar words, along with a plot over various time slices based on the user-determined perplexity value.

To execute the baseline evaluation script, run the following in the terminal:

`python nyt_trajectory.py`

The script will prompt the user with the following question: 

```Which word would you like to visualize the trajectory for?:```

Enter the word to create a time-based trajectory based on the pre-existing word embeddings.

After it finds the most similar words at each time slice, the code will prompt the user to choose the perplexity:

```Enter the perplexity value (5-50) for the tSNE projection or 'n' to quit:```

The perplexity value is used to generate a plot of a 2D tSNE projection. After closing the plot, it will prompt the user with this option again, so the user can generate projections with varying perplexities.

Visualized results for the baseline embeddings can be found in the file **baseline.md**.

Evaluation methods for feature-based word embeddings generated from the blog dataset will be added in the next iteration.

## Trajectory Visualization
Trajectory visualization for temporal embeddings per section 5.1 in [Yao et al., 2018](https://arxiv.org/pdf/1703.00607.pdf)

The 2D t-SNE projection of a word and its most similar words over various time slices are plotted with a user determined perplexity.

After downloading the repo, download **baseline_embeddings.tar.gz** from the [drive](https://drive.google.com/drive/folders/1UM289agQDAwjwO30izEh7dTI428suyww?usp=sharing) and extract it locally as described above.

To execute the baseline evaluation script, run the following in terminal:

`python nyt_trajectory.py`

To execute the extension evaluation script, run the following in terminal:

`python blog_trajectory.py`

The user will be prompted with

`Which word would you like to visualize the trajectory for?:`

Type the word to create a trajectory for

Then, after it finds the most similar words at each time slice, it will prompt the user to choose perplexity

`Enter the perplexity value (5-50) for the tSNE projection or 'n' to quit:`

This perplexity is used to generate a plot of a 2D t-SNE projection.
After closing the plot, it will prompt the user with this again, so the user can generate projections with varying perplexities.

## How To Run Quantitative Analysis
We implement the semantic similarity baselines outlined in section 6.1 of [Yao et al., 2018](https://arxiv.org/pdf/1703.00607.pdf). 
In particular, we are clustering words according to their embeddings via spherical k-means. (The evaluation script currently uses k=10). Then, we use Normalized Mutual Information (NML) and F-Score to determine semantic similarity. 

To execute the extension evaluation script, run the following in terminal:

`python score.py`

The user will be prompted with

`To select an embedding, enter a number 0 through 4:`

Enter the number corresponding with the embedding to evaluate.

|index|category|
|---|---|
|0| Static|  
|1| Time | 
|2| Age | 
|3| Topic (Computer Similarity) |
|4| Topic (Human Similarity) |

The script will then output the NMF and F_beta scores, as well as a numpy array assigning a cluster to each word in the embedding.

## References
1. Zijun Yao, Yifan Sun, Weicong Ding, Nikhil Rao, and Hui Xiong. 2018. Dynamic word embeddings for evolving semantic discovery. arXiv:1703.00607 (2018).
2. Nikhil Garg, Londa Schiebinger, Dan Jurafsky, and James Zou. 2017. Word embeddings quantify 100 years of gender and ethnic stereotypes. arXiv:1711.08412 (2017).
3. Bin Wang, Angela Wang, Fenxiao Chen, Yuncheng Wang, C.-C. and Jay Kuo. 2019. Evaluating word embedding models: methods and experimental results. arXiv:1901.09785 (2019).
4. Alessio Ferrari, Beatrice Donati, and Stefania Gnesi. 2017. Detecting domain-specific ambiguities: An NLP approach based on wikipedia crawling and word embeddings. In Proceedings of the 2017 IEEE 25th International Requirements Engineering Conference Workshops, pages 393–399.
